# Cursor Rules for OnlyFans Chat

## Код

### Структура проекта
- Новые компоненты чата размещаются в директории `src/components/chat/`
- Новые компоненты сообщений размещаются в директории `src/components/message/`
- Общие UI компоненты размещаются в директории `src/components/ui/`
- Хуки размещаются в директории `src/hooks/`
- Типы размещаются в директории `src/types/`
- Утилиты размещаются в директории `src/utils/`

### Стиль кода
- Использовать функциональные компоненты с хуками вместо классовых
- Использовать TypeScript для всех новых файлов
- Придерживаться типизации для всех функций и компонентов
- Использовать деструктуризацию для пропсов компонентов
- Избегать использования any, используя правильную типизацию
- Использовать кастомные хуки для изоляции логики

### Стиль CSS
- Использовать Tailwind CSS для стилизации
- Использовать clsx/tailwind-merge для условных классов
- Предпочтительно использовать утилитарные классы Tailwind вместо custom CSS
- При необходимости кастомных стилей, создавать их в модульном CSS файле

## Компоненты

### Именование
- Компоненты называются в PascalCase (например, `MessageItem.tsx`)
- Хуки называются с префиксом use в camelCase (например, `useMessages.ts`)
- Утилиты называются в camelCase (например, `formatDate.ts`)
- Типы/интерфейсы называются в PascalCase с описательными именами (например, `MessageProps`)

### Структура компонентов
- Экспортировать компоненты как default export
- Определять типы пропсов через интерфейс с постфиксом Props
- Использовать React.memo() для оптимизации рендеринга тяжелых компонентов
- Разделять большие компоненты на более мелкие, переиспользуемые части

## Хуки
- Разделять логику на отдельные хуки с фокусом на конкретной функциональности
- Поддерживать обработку ошибок внутри хуков
- Возвращать объект с именованными свойствами для лучшей читаемости
- Документировать входные параметры и возвращаемые значения

## TypeScript
- Использовать строгую типизацию (strict: true)
- Избегать использования any и unknown там, где можно определить конкретный тип
- Использовать интерфейсы для определения форм данных и пропсов компонентов
- Использовать enum для значений с фиксированным набором вариантов
- Использовать generics для переиспользуемых утилит и хуков

## State Management
- Использовать React Context API для глобального состояния
- Использовать useState и useReducer для локального состояния
- Использовать иммутабельные обновления состояния
- Минимизировать передачу пропсов через несколько уровней компонентов

## Производительность
- Оптимизировать ре-рендеринг с помощью React.memo, useMemo и useCallback
- Использовать виртуализацию для длинных списков
- Внедрять ленивую загрузку компонентов и данных
- Оптимизировать работу с медиафайлами через предварительную загрузку и кэширование

## Git
- Делать атомарные коммиты с четкими сообщениями
- Использовать feature ветки для новых функций
- Придерживаться соглашения по именованию веток: feature/*, fix/*, refactor/*
- Проводить code review перед мержем в основную ветку 